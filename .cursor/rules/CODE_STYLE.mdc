---
alwaysApply: true
---
## 二、目录与模块划分

- **单一职责包**
  - 每个包只负责一个清晰领域：如配置、缓存、日志、存储、验证、响应等。
  - 禁止循环依赖，必要时通过接口或回调打断依赖方向。

- **典型包结构建议**
  - `xxx/manager.go`：该领域对外的统一入口（如 `Manager` / `Client`）。
  - `xxx/options.go`：配置选项与 `Option` 函数。
  - `xxx/types.go` 或 `xxx/types/*.go`：公共类型、配置结构体。
  - `xxx/errors.go`：错误变量、错误类型定义。
  - `xxx/internal/...`：不对外暴露的内部实现细节。
  - `xxx/provider_xxx/`：具体厂商/驱动实现（如 `aliyunoss`、`mysql` 等），对外统一通过上层包抽象暴露。

- **文件长度与拆分**
  - 单个 Go 文件建议控制在 **400 行以内**，超过时优先按职责切分为多个文件：
    - 例如：`config_loader.go`、`config_manager.go`、`config_watcher.go`。

---

## 三、命名规范

- **包名**
  - 全小写，无下划线，语义明确，优先用单数：`config`、`logger`、`storage`。
  - 避免使用过短或模糊包名：不推荐 `util`、`common`；如必须使用，应限制职责极少。

- **类型与接口**
  - 导出类型使用大驼峰（PascalCase），表达「是什么」：
    - 结构体：`ConfigManager`、`JWTManager`。
    - 接口：行为型接口以 `er` 结尾，如 `Logger`、`Storage`、`Validator`。
    - 组合接口可以使用 `Service`、`Manager` 等后缀。

- **函数与方法**
  - 普通函数使用小驼峰（camelCase）：`loadConfig`、`parseToken`。
  - 构造函数统一使用 `NewXxx` 形式，例如：

```go
func NewStorageManager(opts ...Option) (*Manager, error)
```

  - 带上下文的函数，第一个参数必须是 `ctx context.Context`，命名必须为 `ctx`：

```go
func (m *Manager) Do(ctx context.Context, req *Request) error
```

- **变量与常量**
  - 局部变量语义清晰，避免无意义缩写：
    - 推荐：`cfg`、`db`、`client`、`logger`。
    - 避免：`c1`、`tmp`、`data1`。
  - 错误变量使用 `ErrXxx` 命名：

```go
var ErrInvalidToken = errors.New("invalid token")
```

  - 常量命名：
    - 导出常量：`DefaultTimeout`、`DefaultBufferSize`。
    - 内部错误码等：可使用 `ALL_CAPS` 或大驼峰，但同一类保持统一风格。

---

## 四、代码风格与结构

- **函数体与复杂度控制**
  - 单个函数逻辑不宜过长，建议控制在 **40 行左右**，最多不超过 80 行。
  - 当函数内部逻辑出现明显「阶段」时，应拆为多个私有辅助函数。

- **条件与分支**
  - 优先使用「早返回」减少嵌套层级：

```go
if err != nil {
    return err
}
// 正常逻辑
```

  - 复杂条件应拆解为具名布尔变量或小函数提升可读性。

- **nil 与零值处理**
  - 对外暴露的函数，如果返回切片或 map：
    - 业务上「空集合」应尽量返回非 nil 但长度为 0 的对象；
    - 避免让调用方额外进行 nil 判断。

- **init 函数使用限制**
  - 禁止在 `init()` 中：
    - 打开网络连接、创建 goroutine；
    - 读取大量配置、执行复杂逻辑。
  - `init()` 只允许：
    - 注册驱动/实现到内部 registry；
    - 设置少量默认值。

---

## 五、错误处理规范

- **禁止以 panic 作为普通控制流**
  - 库代码中除极少数不可恢复的编程错误外，不得使用 `panic` 代替错误返回。
  - 在可预见失败场景（校验失败、外部系统不可用等）必须返回 `error`。

- **错误返回与包装**
  - 优先使用 `fmt.Errorf("context: %w", err)` 进行错误包装，保留调用栈上下文。
  - 不做无意义的二次包装：如果上层不能提供更多上下文，可直接透传。

- **错误信息**
  - 错误信息要简洁精准，描述「发生了什么」和关键参数，不写与日志重复的长句。
  - 错误字符串首字母不大写，不以句号结尾（遵循 Go 社区惯例）。

- **错误分类与边界**
  - 尽量区分：
    - 调用方可恢复的错误（如参数错误、外部服务失败）；
    - 不可恢复的内部编程错误（如数据结构不变式被破坏）。
  - 基础库尽量只负责「发现并报告错误」，由上层服务决定如何降级或返回 HTTP 状态码。

---

## 六、配置与环境变量

- **配置集中管理**
  - 所有与配置相关的结构体定义建议集中在 `config` 模块（或各模块的 `types` 子目录）。
  - 配置加载逻辑统一封装：外部只关心「如何构建配置」与「如何获取配置」，不关心底层来源。

- **环境变量与默认值**
  - 使用环境变量时，必须为每一项配置设计合理默认值，避免因缺失导致 panic。
  - 决定配置优先级的一般建议：
    1. 显式传入的 Options；
    2. 配置文件；
    3. 环境变量；
    4. 库内内置默认值。

- **不可变配置**
  - 配置对象一旦构建完成，应尽量视为只读，不在运行时随意修改。
  - 如需支持热更新，应通过清晰的接口暴露，并在文档中说明线程安全策略。

---

## 七、并发与性能

- **并发安全**
  - 对外暴露的 `Manager` / `Client` 默认应当是线程安全的，除非文档中明确说明。
  - 使用 `sync.Mutex`、`sync.RWMutex` 等同步原语时，需要：
    - 尽量缩小锁粒度；
    - 避免在持锁期间做网络 IO、磁盘 IO 或长时间操作。

- **goroutine 管理**
  - 启动 goroutine 必须有明确的生命周期与退出条件：
    - 通过 `context.Context` 或显式的 `Close` / `Stop` 方法控制退出；
    - 禁止「一旦启动永不退出」且无文档说明的后台协程。

- **资源复用**
  - 连接、客户端实例等重资源应复用，而不是频繁创建销毁。
  - 适当使用连接池或官方客户端的内部池化能力。

---

## 八、公共 API 设计

- **清晰的分层**
  - 对外暴露的 API 应简洁、稳定，内部实现细节隐藏在包内或 `internal` 子包中。
  - 避免在公共接口中大量透出第三方库类型，推荐做一层适配：
    - 便于未来替换实现；
    - 不让调用方被具体库绑死。

- **Options 模式**
  - 对于可选参数较多的构造函数，推荐使用 Options 模式：

```go
type Option func(*Options)

type Options struct {
    Timeout time.Duration
    // ...
}

func WithTimeout(d time.Duration) Option {
    return func(o *Options) {
        o.Timeout = d
    }
}
```

  - 构造函数统一为：

```go
func NewManager(opts ...Option) (*Manager, error)
```

- **上下文传递**
  - 任何可能涉及：
    - 网络请求；
    - 远程服务访问；
    - 慢 IO 操作；
    - 可取消/超时操作；
    都应在 API 中传入 `context.Context`，并在内部遵循 ctx 的取消与超时。

---

## 九、注释与文档

- **注释基本要求**
  - 所有导出类型、导出函数必须有 GoDoc 风格注释，以其名称开头：

```go
// Manager 管理底层存储客户端，提供统一的读写接口。
type Manager struct {
    // ...
}
```

  - 注释用简洁中文或中英文结合，描述「做什么」和「何时使用」，不赘述「怎么实现」。

- **内部实现注释**
  - 对于复杂算法、边界条件、特殊兼容逻辑，需要在代码附近加简短说明。
  - 避免写「废话注释」（如 `// add 1 to i` 紧贴 `i++`）。

---

## 十、演进与扩展

- 本规范不是一成不变的，应随着项目发展定期回顾。